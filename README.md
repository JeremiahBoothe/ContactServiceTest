# ContactServiceTest

## How can I ensure that my code, program, or software is functional and secure?
Application of the many different types of testing, both static helps with the process. No single form of testing can prove that a program is free from defects. What it can do is show you that at least in the scope of that form of testing, no errors were found.  Having good coverage makes that lens a little bigger and applying a broader set of testing methods increases the likeliness that my code is functional. Reducing defects increases security, and applying various methodologies such as keeping packages and methods as private or protected as possible, idiomatic programming, or the use of design and architectural patterns helps bring the code to standards that have been developed over decades.

Owasp dependency checks are also a great way to check for security, and ensure that no new vulnerabilities were introduced through imports.

## How do I interpret user needs and incorporate them into a program?
The key is communication. Interpretations are almost always a little bit off. As a software engineer I have many responsibilities to resolve and balance. Sometimes I have to think beyond what the user requests because they may not consider to include certain criteria with such a high level view. I also have to make sure to not go overboard with things that may not be reqiured or desired.  Communication in the form of requirements gathering and feedback keep efforts aligned with needs while providing the best service and product.

## How do I approach designing software?
I have a lot of different methods. First off I want the software to do something, and within that I have expectations of how it should behave from years of experience using computers, smart tv's, and smart phones. While I do seek to be somewhat original in my process, there are elements of design that I prefer to avoid. I don't want an app to feel clunky or unintuitive. I want it to feel smooth and natural to interact with. Then I read documents and construct Class diagrams. The documents help me understand what various classes are capable of, often times far more than I need for any given task, and the UML diagrams give me a pretty and simplified visual reference to work from as I wire the classes together to achieve the end goal. There's plenty of experimentation, rough drafts and deleted code, and eventual refinement where I structure my code and check that the comments are effectively communicating what the code is doing and sometimes a little bit of my thought process behind it.